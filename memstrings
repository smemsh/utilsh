#!/usr/bin/env bash
#
# memstrings
#   dump contents of heap memory and filter through strings
#
# usage:
#   memstrings <pid>
#
# desc:
#   - reads /proc/pid/maps to determine heap mapping, and reads only that
#   - pipe result to strings
#
# scott@smemsh.net
# https://github.com/smemsh/utilsh/
# https://spdx.org/licenses/GPL-2.0
#

usage_until=desc:
usagex () { usage; false; exit; }
usage ()
{
	grep -B 999 -m 1 '^$' "$BASH_SOURCE"  | # until first blank
	grep -B 999 -m 1 "^..${usage_until}$" | # until stop record
	head -n -2 |	# but not the match
	tail -n +3 |	# or interpreter line
	cut -b 3-	# strip comment prefix
}

process_args ()
{
	eval set -- $(getopt -n $invname -o h -l help -- "$@")
	while true; do case $1 in
	(-h|--help) usage; exit;;
	(--) shift; break;;
	(*) usagex
	esac; done

	[[ $1 =~ ^[[:digit:]]+$ ]] || usagex

	args=("$@")
}

check_sanity ()
{
	true
}

# dumps heap through strings and pages
memstrings ()
{
	local line range rstart rend

	local pid=${1:?}
	local filebase=/proc/$pid
	local mapfile=$filebase/maps
	local memfile=$filebase/mem

	while read -a line
	do if [[ "${line[-1]}" == "[heap]" ]]; then
	range=${line[0]}
	rstart=0x${range%-*}
	rend=0x${range#*-}
	break; fi; done \
	< $mapfile

	dd \
		if=$memfile bs=4k \
		skip=$((rstart)) iflag=skip_bytes \
		count=$((rend - rstart)) iflag=count_bytes \
		status=none \
	| strings -Ul
}

main ()
{
	process_args "$@" || exit
	check_sanity || exit

	if [[ $(declare -F $invname) ]]
	then $invname "${args[@]}"
	else echo "unimplemented command '$invname'" >&2; fi
}

invname=${0##*/} # 0.8.0
invdir=${0%/*}

main "$@"
